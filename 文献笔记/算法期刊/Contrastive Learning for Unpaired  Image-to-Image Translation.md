![[82af552b-18f8-49f8-86e7-8fc89bf5d8ac.png]]
CUT 里的“==patch”不是在原图上裁一个小块，而是某一层特征图上某个空间位置的**特征向量**==。之所以用 `H*W`，是因为这一层有 `H×W` 个空间位置；把 `(H,W)` 按固定顺序展平成一维索引 `s∈[0, H·W)`（例如 `s=h·W+w`），每个 `s` 就唯一对应到特征图上的一个格子 `(h,w)`，也就对应到那一格的 C 维向量。对 key 路先随机出这组 `patch_id`，再在 query 路用同一组 `patch_id` 取样，就实现了“同层同位置”的正样本对齐。

为什么这个“一格特征”能代表你图中画框的一个区域，靠的是**感受野**。卷积+下采样会让特征图每个位置“看见”输入图像的一块邻域：

- 每往深一层，感受野按递推增大：`j_l = j_{l-1} * s_l`（累计步长/采样间隔），`r_l = r_{l-1} + (k_l-1) * j_{l-1}`（感受野大小），其中 `k_l、s_l` 是第 l 层卷积的核和步幅。
    
- 以 CUT 的 ResNet 生成器为例：7×7,s=1 → 下采样(3×3,s=2)×2 → 一堆 3×3,s=1 的残差块。到残差段时网格已经是原图的 1/4 分辨率（`j≈4`），每个位置对应输入上大约几十个像素的区域；随着残差块层数增加，这个区域继续变大。所以你在论文配图里看到的彩色方框只是**示意**——真实“patch”是某个特征位置的感受野覆盖区，不是严格的像素裁剪。
    

因此：

- `H*W` 是“这一层所有位置的数量”；
    
- `patch_id` 选的是这些位置的索引，和位置信息是一一对应的；
    
- 正样本对齐靠“同一层同一位置”的索引共享；
    
- 你在原图上画框只是把这个位置的感受野投回去的可视化，确实不是“直接在原图裁块”。
    

小提示：在实现里展平用的是 `(B,C,H,W) → (B,H,W,C) → (B,S,C)`，取样 `x = feat[:, ids, :]` 得到 `(B,K,C)`；这里的 “patch”=一根 C 维向量。想可视化哪个位置的感受野，可以把 `s` 还原成 `(h,w)`，再按上面的递推估算 `r_l、j_l` 画到输入图像上，会比画任意正方形更贴近真实覆盖区